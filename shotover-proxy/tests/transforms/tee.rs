use crate::shotover_process;
use hyper::{body, Body, Client, Method, Request, Response};
use test_helpers::connection::redis_connection;
use test_helpers::docker_compose::docker_compose;
use test_helpers::shotover_process::{EventMatcher, Level};

#[tokio::test(flavor = "multi_thread")]
async fn test_ignore_matches() {
    let shotover = shotover_process("tests/test-configs/tee/ignore.yaml")
        .start()
        .await;

    let mut connection = redis_connection::new_async("127.0.0.1", 6379).await;

    let result = redis::cmd("SET")
        .arg("key")
        .arg("myvalue")
        .query_async::<_, String>(&mut connection)
        .await
        .unwrap();

    assert_eq!("42", result);
    shotover.shutdown_and_then_consume_events(&[]).await;
}

#[tokio::test(flavor = "multi_thread")]
async fn test_ignore_with_mismatch() {
    let shotover = shotover_process("tests/test-configs/tee/ignore_with_mismatch.yaml")
        .start()
        .await;

    let mut connection = redis_connection::new_async("127.0.0.1", 6379).await;

    let result = redis::cmd("SET")
        .arg("key")
        .arg("myvalue")
        .query_async::<_, String>(&mut connection)
        .await
        .unwrap();

    assert_eq!("42", result);
    shotover.shutdown_and_then_consume_events(&[]).await;
}

#[tokio::test(flavor = "multi_thread")]
async fn test_log_matches() {
    let shotover = shotover_process("tests/test-configs/tee/log.yaml")
        .start()
        .await;

    let mut connection = redis_connection::new_async("127.0.0.1", 6379).await;

    let result = redis::cmd("SET")
        .arg("key")
        .arg("myvalue")
        .query_async::<_, String>(&mut connection)
        .await
        .unwrap();

    assert_eq!("42", result);
    shotover.shutdown_and_then_consume_events(&[]).await;
}

#[tokio::test(flavor = "multi_thread")]
async fn test_log_with_mismatch() {
    let shotover = shotover_process("tests/test-configs/tee/log_with_mismatch.yaml")
        .start()
        .await;

    let mut connection = redis_connection::new_async("127.0.0.1", 6379).await;

    let result = redis::cmd("SET")
        .arg("key")
        .arg("myvalue")
        .query_async::<_, String>(&mut connection)
        .await
        .unwrap();

    assert_eq!("42", result);
    shotover
        .shutdown_and_then_consume_events(&[EventMatcher::new()
            .with_level(Level::Warn)
            .with_target("shotover::transforms::tee")
            .with_message(
                r#"Tee mismatch: 
chain response: ["Redis BulkString(b\"42\"))"] 
tee response: ["Redis BulkString(b\"41\"))"]"#,
            )])
        .await;
}

#[tokio::test(flavor = "multi_thread")]
async fn test_fail_matches() {
    let shotover = shotover_process("tests/test-configs/tee/fail.yaml")
        .start()
        .await;

    let mut connection = redis_connection::new_async("127.0.0.1", 6379).await;

    let result = redis::cmd("SET")
        .arg("key")
        .arg("myvalue")
        .query_async::<_, String>(&mut connection)
        .await
        .unwrap();

    assert_eq!("42", result);
    shotover.shutdown_and_then_consume_events(&[]).await;
}

#[tokio::test(flavor = "multi_thread")]
async fn test_fail_with_mismatch() {
    let shotover = shotover_process("tests/test-configs/tee/fail_with_mismatch.yaml")
        .start()
        .await;

    let mut connection = redis_connection::new_async("127.0.0.1", 6379).await;

    let err = redis::cmd("SET")
        .arg("key")
        .arg("myvalue")
        .query_async::<_, String>(&mut connection)
        .await
        .unwrap_err()
        .to_string();

    let expected = "An error was signalled by the server - ResponseError: ERR The responses from the Tee subchain and down-chain did not match and behavior is set to fail on mismatch";
    assert_eq!(expected, err);
    shotover.shutdown_and_then_consume_events(&[]).await;
}

#[tokio::test(flavor = "multi_thread")]
async fn test_subchain_matches() {
    let _compose = docker_compose("tests/test-configs/redis/passthrough/docker-compose.yaml");
    let shotover = shotover_process("tests/test-configs/tee/subchain.yaml")
        .start()
        .await;

    let mut shotover_connection = redis_connection::new_async("127.0.0.1", 6379).await;
    let mut mismatch_chain_redis = redis_connection::new_async("127.0.0.1", 1111).await;
    redis::cmd("SET")
        .arg("key")
        .arg("myvalue")
        .query_async::<_, String>(&mut mismatch_chain_redis)
        .await
        .unwrap();

    let mut result = redis::cmd("SET")
        .arg("key")
        .arg("notmyvalue")
        .query_async::<_, String>(&mut shotover_connection)
        .await
        .unwrap();

    assert_eq!(result, "42");

    result = redis::cmd("GET")
        .arg("key")
        .query_async::<_, String>(&mut mismatch_chain_redis)
        .await
        .unwrap();

    assert_eq!(result, "myvalue");
    shotover.shutdown_and_then_consume_events(&[]).await;
}

#[tokio::test(flavor = "multi_thread")]
async fn test_subchain_with_mismatch() {
    let _compose = docker_compose("tests/test-configs/redis/passthrough/docker-compose.yaml");
    let shotover = shotover_process("tests/test-configs/tee/subchain_with_mismatch.yaml")
        .start()
        .await;

    let mut shotover_connection = redis_connection::new_async("127.0.0.1", 6379).await;
    let mut mismatch_chain_redis = redis_connection::new_async("127.0.0.1", 1111).await;

    // Set the value on the top level chain redis
    let mut result = redis::cmd("SET")
        .arg("key")
        .arg("myvalue")
        .query_async::<_, String>(&mut shotover_connection)
        .await
        .unwrap();

    assert_eq!(result, "42");

    // When the mismatch occurs, the value should be sent to the mismatch chain's redis
    result = redis::cmd("GET")
        .arg("key")
        .query_async::<_, String>(&mut mismatch_chain_redis)
        .await
        .unwrap();

    assert_eq!("myvalue", result);
    shotover.shutdown_and_then_consume_events(&[]).await;
}

async fn read_response_body(res: Response<Body>) -> Result<String, hyper::Error> {
    let bytes = body::to_bytes(res.into_body()).await?;
    Ok(String::from_utf8(bytes.to_vec()).expect("response was not valid utf-8"))
}

async fn hyper_request(uri: String, method: Method, body: Body) -> Response<Body> {
    let client = Client::new();

    let req = Request::builder()
        .method(method)
        .uri(uri)
        .body(body)
        .expect("request builder");

    client.request(req).await.unwrap()
}

#[tokio::test(flavor = "multi_thread")]
async fn test_switch_main_chain() {
    let shotover = shotover_process("tests/test-configs/tee/switch_chain.yaml")
        .start()
        .await;

    for i in 1..=3 {
        let redis_port = 6370 + i;
        let switch_port = 1230 + i;

        let mut connection = redis_connection::new_async("127.0.0.1", redis_port).await;

        let result = redis::cmd("SET")
            .arg("key")
            .arg("myvalue")
            .query_async::<_, String>(&mut connection)
            .await
            .unwrap();

        assert_eq!("a", result);

        let _ = hyper_request(
            format!(
                "http://localhost:{}/transform/tee/result-source",
                switch_port
            ),
            Method::PUT,
            Body::from("tee-chain"),
        )
        .await;

        let res = hyper_request(
            format!(
                "http://localhost:{}/transform/tee/result-source",
                switch_port
            ),
            Method::GET,
            Body::empty(),
        )
        .await;
        let body = read_response_body(res).await.unwrap();
        assert_eq!("tee-chain", body);

        let result = redis::cmd("SET")
            .arg("key")
            .arg("myvalue")
            .query_async::<_, String>(&mut connection)
            .await
            .unwrap();

        assert_eq!("b", result);

        let _ = hyper_request(
            format!(
                "http://localhost:{}/transform/tee/result-source",
                switch_port
            ),
            Method::PUT,
            Body::from("regular-chain"),
        )
        .await;

        let result = redis::cmd("SET")
            .arg("key")
            .arg("myvalue")
            .query_async::<_, String>(&mut connection)
            .await
            .unwrap();

        assert_eq!("a", result);
    }

    shotover
        .shutdown_and_then_consume_events(&[EventMatcher::new()
            .with_level(Level::Warn)
            .with_count(tokio_bin_process::event_matcher::Count::Times(3))])
        .await;
}
