# Shotover Proxy - Context for AI Assistants

This file provides context about recent significant changes to help AI coding assistants understand the codebase better.

## Recent Changes

### PR #1949: Using OwnedFd instead of RawFd (October 2025)

**Status:** Open PR by @ric-pro  
**Branch:** `RawFDtoOwnedFD`  
**Files Changed:**
- `shotover/src/hot_reload/protocol.rs`
- `shotover/src/hot_reload/server.rs`
- `shotover/src/hot_reload/client.rs`
- `shotover/src/server.rs`

**Summary:**  
This PR refactors the hot reload mechanism to use `OwnedFd` instead of `RawFd` for transferring listening socket file descriptors between shotover instances. This improves resource management and prevents potential resource leaks.

**Key Changes:**

1. **Proper ownership semantics:**
   - Replaced `FileDescriptor(RawFd)` wrapper with direct `OwnedFd` usage
   - Ensures proper lifetime management of file descriptors
   - The old instance now properly closes and unbinds listening sockets after transfer

2. **File descriptor handling:**
   - `OwnedFd` is converted to `RawFd` only during the actual ancillary data transfer
   - File descriptors are explicitly dropped after transfer to immediately close the originals
   - The kernel duplicates FDs during transfer, so immediate closure is safe

3. **Shutdown bug fix:**
   - Added `futures::pending().await` after hot reload to prevent the listener from attempting to recreate the socket after transfer
   - This ensures the TcpCodecListener waits indefinitely after handing off its listener
   - Simple `return Ok(())` wouldn't work as it only returns to the `tokio::select!` macro level, not from the enclosing function

4. **Test updates:**
   - Modified test mocks to create valid `OwnedFd` instances using Unix socket pairs
   - Changed from dummy raw file descriptor integers to proper socket-backed file descriptors
   - Example: `let (sock, _) = std::os::unix::net::UnixStream::pair().unwrap(); sock.into()`

5. **API changes:**
   - Removed `FileDescriptor` struct from `protocol.rs`
   - Changed `HotReloadListenerResponse` to use `OwnedFd` directly
   - Updated `process_request` in `server.rs` to return `Vec<OwnedFd>` instead of `Vec<RawFd>`
   - Modified `handle_hot_reload_request` to use `listener.take()` to consume the listener
   - Added conversion from tokio `TcpListener` to std `TcpListener` to `OwnedFd`

**Technical Details:**

- **Hot Reload Process:** When a new shotover instance starts, it requests listening sockets from the old instance via Unix domain socket with ancillary data transfer
- **File Descriptor Transfer:** The old instance extracts its listening socket FDs and sends them to the new instance, which can then bind to the same ports without interruption
- **Resource Cleanup:** Using `OwnedFd` ensures proper RAII semantics - when the `OwnedFd` is dropped, the file descriptor is automatically closed
- **Important Note:** After transferring the listener FD, the original TcpCodecListener must not continue its run loop, as attempting to recreate the listener would fail (port already in use)

**Code Examples:**

Before (using RawFd):
```rust
pub struct FileDescriptor(pub RawFd);

let fd = listener.as_raw_fd();
HotReloadListenerResponse::HotReloadResponse {
    port,
    listener_socket_fd: FileDescriptor(fd),
}
```

After (using OwnedFd):
```rust
use std::os::unix::io::OwnedFd;

let owned_fd: OwnedFd = listener.into_std()?.into();
HotReloadListenerResponse::HotReloadResponse {
    port,
    listener_socket_fd: owned_fd,
}
```

**Why This Matters:**
- Prevents resource leaks from unclosed file descriptors
- Makes ownership and lifecycle of file descriptors explicit
- Follows Rust best practices for managing OS resources
- Fixes edge cases where sockets weren't properly unbound after hot reload
