# Shotover Proxy - Context for AI Assistants

This file provides context about recent significant changes to help AI coding assistants understand the codebase better.

## Recent Changes

### PR #1949: Using OwnedFd instead of RawFd (October 2025)

**Status:** Open PR (not yet merged) by @ric-pro  
**Branch:** `RawFDtoOwnedFD`  
**PR Link:** https://github.com/shotover/shotover-proxy/pull/1949  
**Files to be Changed:**
- `shotover/src/hot_reload/protocol.rs`
- `shotover/src/hot_reload/server.rs`
- `shotover/src/hot_reload/client.rs`
- `shotover/src/server.rs`

**Summary:**  
This PR **proposes** to refactor the hot reload mechanism to use `OwnedFd` instead of `RawFd` for transferring listening socket file descriptors between shotover instances. This will improve resource management and prevent potential resource leaks.

**Note:** The changes described below are from the PR and are **not yet in the main codebase**. The current implementation still uses `FileDescriptor(RawFd)`.

**Key Changes:**

1. **Proper ownership semantics:**
   - Will replace `FileDescriptor(RawFd)` wrapper with direct `OwnedFd` usage
   - Will ensure proper lifetime management of file descriptors
   - The old instance will properly close and unbind listening sockets after transfer

2. **File descriptor handling:**
   - `OwnedFd` will be converted to `RawFd` only during the actual ancillary data transfer
   - File descriptors will be explicitly dropped after transfer to immediately close the originals
   - The kernel duplicates FDs during transfer, so immediate closure is safe

3. **Shutdown bug fix:**
   - Will add `futures::pending().await` after hot reload to prevent the listener from attempting to recreate the socket after transfer
   - This will ensure the TcpCodecListener waits indefinitely after handing off its listener
   - Simple `return Ok(())` wouldn't work as it only returns to the `tokio::select!` macro level, not from the enclosing function

4. **Test updates:**
   - Will modify test mocks to create valid `OwnedFd` instances using Unix socket pairs
   - Will change from dummy raw file descriptor integers to proper socket-backed file descriptors
   - Example: `let (sock, _) = std::os::unix::net::UnixStream::pair().unwrap(); sock.into()`

5. **API changes:**
   - Will remove `FileDescriptor` struct from `protocol.rs`
   - Will change `HotReloadListenerResponse` to use `OwnedFd` directly
   - Will update `process_request` in `server.rs` to return `Vec<OwnedFd>` instead of `Vec<RawFd>`
   - Will modify `handle_hot_reload_request` to use `listener.take()` to consume the listener
   - Will add conversion from tokio `TcpListener` to std `TcpListener` to `OwnedFd`

**Technical Details:**

- **Hot Reload Process:** When a new shotover instance starts, it requests listening sockets from the old instance via Unix domain socket with ancillary data transfer
- **File Descriptor Transfer:** The old instance extracts its listening socket FDs and sends them to the new instance, which can then bind to the same ports without interruption
- **Resource Cleanup:** Using `OwnedFd` ensures proper RAII semantics - when the `OwnedFd` is dropped, the file descriptor is automatically closed
- **Important Note:** After transferring the listener FD, the original TcpCodecListener must not continue its run loop, as attempting to recreate the listener would fail (port already in use)

**Code Examples:**

Current implementation (before PR #1949):
```rust
pub struct FileDescriptor(pub RawFd);

let fd = listener.as_raw_fd();
HotReloadListenerResponse::HotReloadResponse {
    port,
    listener_socket_fd: FileDescriptor(fd),
}
```

Proposed implementation (after PR #1949):
```rust
use std::os::unix::io::OwnedFd;

let owned_fd: OwnedFd = listener.into_std()?.into();
HotReloadListenerResponse::HotReloadResponse {
    port,
    listener_socket_fd: owned_fd,
}
```

**Why This Matters:**
- Will prevent resource leaks from unclosed file descriptors
- Will make ownership and lifecycle of file descriptors explicit
- Follows Rust best practices for managing OS resources
- Will fix edge cases where sockets weren't properly unbound after hot reload
